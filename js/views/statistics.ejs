<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Statistics Overview</title>
    <!--Load the AJAX API-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.18.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>



</head>
<body onload="fetch_user_data()">


<div id = "fan" style="width: 40%; position: absolute; top: 20%; left: 70%; transform: translate(-50%, -50%);margin-left: 50px;margin-top: 20px">
    <canvas id="fanChart" onload="read_data()" onclick = "window.location.href = '/statistics/fan'"></canvas>
</div>

<div id = "pressure" style="width: 40%; position: absolute; top: 20%; left: 30%; transform: translate(-50%, -50%);margin-right: 50px;margin-top: 20px">
    <canvas id="pressureChart" onload="read_data()" onclick = "window.location.href = '/statistics/pressure'"></canvas>
</div>

<div id = "user"
     style="width: 40%; position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%);">
    <canvas id="userChart" onclick = "window.location.href = '/statistics/user'"></canvas>
</div>
<script>
    const sec_per_day = 86400000;
    const fanCtx = document.getElementById('fanChart').getContext("2d");
    const presCtx = document.getElementById('pressureChart').getContext("2d");
    //Fan data graph
    const fan_graph = new Chart(fanCtx, {
        type: "line",
        data: {
            labels: [],
            datasets: [{
                data: [],
                borderColor: "green",
                fill: false,
                label: "Fan Speed Percentage"
            }]
        },
        options: {
            scales:{
                yAxes: [{
                    ticks: {
                        min: 0,
                        max: 100
                    }
                }],
                xAxes: [{
                    ticks:{
                        userCallback: function(v) { return epoch_to_hh_mm_ss(v) },
                    }
                }]
            },
            responsive: true,
            title: {
                display: true,
                text: "Fan value"
            },
            padding: {
                top: 10,
                bottom: 30
            }
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    return data.datasets[tooltipItem.datasetIndex].label + ': ' + epoch_to_hh_mm_ss(tooltipItem.xAxes)
                }
            }
        }
    });
    const pressure_graph = new Chart(presCtx, {
        type: "line",
        data: {
            labels: [],
            datasets: [{
                data: [],
                borderColor: "blue",
                fill: false,
                label: "Pressure val"
            }]
        },
        options: {
            scales:{
                yAxes: [{
                    ticks: {

                        min: 0,
                        max: 140
                    }
                }],
                xAxes: [{
                    ticks:{
                        userCallback: function(v) { return epoch_to_hh_mm_ss(v) },
                    }
                }]
            },
            responsive: true,
            title: {
                display: true,
                text: "Pressure value"
            },
            padding: {
                top: 10,
                bottom: 30
            }
        },
        tooltips: {
            callbacks: {
                label: function(tooltipItem, data) {
                    return data.datasets[tooltipItem.datasetIndex].label + ': ' + epoch_to_hh_mm_ss(tooltipItem.xAxes)
                }
            }
        }

    });
    /**
     * Changing the data format from milliseconds to HH:MM:SS
     * @function
     * @param int epoch - Data which their format need to be converted
     * @return Formatted data string
     */
    function epoch_to_hh_mm_ss(epoch) {
        return new Date(epoch).toString().substr(16, 8)
    }

    //Receiving data and updating the chart from server side
    const read_data = () => {
        fetch('/mutable-data').then(tmp => tmp.json()).then(data => {


            fan_graph.data.labels.push(data.timestamp);
            fan_graph.data.datasets[0].data.push(data.speed);
            pressure_graph.data.labels.push(data.timestamp);
            pressure_graph.data.datasets[0].data.push(data.pressure);

            fan_graph.update();
            pressure_graph.update();

        });
    }
    //Receiving the data every 5 seconds
    setInterval(read_data, 5000);

    function fetch_user_data() {
        //Getting logout and login times of the user from server side.
        fetch('/user_data').then(tmp => tmp.json()).then(arr => {
            const x = arr.x;
            const logout_time = arr.logout_time;
            const y = arr.y;
            // const diff = arr.y;
            // const time_converted = [];
            // diff.forEach(ms => {
            //     const days = Math.floor(ms / (24 * 60 * 60 * 1000));
            //     const daysms = ms % (24 * 60 * 60 * 1000);
            //     const hours = Math.floor(daysms / (60 * 60 * 1000));
            //     const hoursms = ms % (60 * 60 * 1000);
            //     const minutes = Math.floor(hoursms / (60 * 1000));
            //     const minutesms = ms % (60 * 1000);
            //     const sec = Math.floor(minutesms / 1000);
            //     time_converted.push(days + ":" + hours + ":" + minutes + ":" + sec);
            // });
            console.log(arr.y);



            for (let i = 0; i < logout_time.length; ++i) {
                const d1 = new Date(x[i]);
                // const d3 = new Date(y[i]);
                const d2 = new Date(x[i + 1]);
                //Checking if the two nearby login data is in the same date or not
                if (d1.getFullYear() === d2.getFullYear()
                    && d1.getMonth() === d2.getMonth()
                    && d1.getDate() === d2.getDate()) {
                    //Combining the session time
                    y[i] = y[i] + y[i + 1];
                    y.splice(i + 1, 1);
                    x.splice(i + 1, 1);
                    console.log(x)
                    i--;
                }

                //Checking if one session time exceeds one day
                for (let i = 0; i < y.length; ++i) {
                    if (y[i] > 86400000) {
                        y[i + 1] += y[i] - sec_per_day;
                        y[i] = sec_per_day;
                    }
                }


            }
            for (let i = 0; i < x.length; i++) {
                x[i] = new Date(x[i]).toString().substring(4, 16);
            }




            //User data graph
            new Chart("userChart", {
                type: "bar",
                data: {
                    labels: x,
                    datasets: [
                        {
                            label: x,
                            data: y,
                            backgroundColor: [
                                'rgb(255, 99, 132)',
                                'rgb(255, 159, 64)',
                                'rgb(255, 205, 86)',
                                'rgb(75, 192, 192)',
                                'rgb(54, 162, 235)',
                                'rgb(153, 102, 255)',
                                'rgb(201, 203, 207)'
                            ]

                        }
                    ]

                },
                options: {
                    title: {
                        display: true,
                        text: "User Data"
                    },
                    scales: {
                        xAxes: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                tooltipFormat: 'MMM DD'
                            }, gridLines: {
                                display: false
                            }
                        },

                        yAxes: [{
                            ticks: {
                                userCallback: function(v) { return epoch_to_hh_mm_ss(v) },
                                stepSize: 86400000/24,
                                beginAtZero: true,
                                steps: 24,
                                max: 86400000
                            }, gridLines: {
                                display: false
                            }
                        }]
                    }
                },
                tooltips: {
                    callbacks: {
                        label: function(tooltipItem, data) {
                            return data.datasets[tooltipItem.datasetIndex].label + ': ' + epoch_to_hh_mm_ss(tooltipItem.yLabel)
                        }
                    }
                }
            });

        })
        /**
         * Changing the data format from milliseconds to HH:MM:SS
         * @function
         * @param int epoch - Data which their format need to be converted
         * @return Formatted data string
         */
        function epoch_to_hh_mm_ss(epoch) {
            return new Date(epoch).toISOString().substr(11, 8)
        }



    }

</script>

</body>
</html>

